## 목차

### [TIL](#til)
- [JVM의 메모리 구조](#jvm의-메모리-구조)
- [class의 상속](#class의-상속)
### [결론](#결론)

## TIL

### JVM의 메모리 구조

이전 23일 JVM의 메모리 구조에 대해 간략하게 정리를 했으나 묘하게 잘 못 이해하고 있는 것 같은 느낌이 들어 다시 조사를 진행하였다.

당시 java에 작성된 모든 코드(plain text)는 메서드 영역 메모리에 저장이 되고, 메서드와 객체는 힙 영역에 존재하며 참조하는 **실제 값**은 ***스택***에 저장된다고 이해하였다.

도식으로 나타내면 아래와 같다

|<center>메서드 영역</center>|<center>참조 관계</center>|<center>힙 영역</center>|<center>참조 관계</center>|<center>스택 영역</center>|
|---|---|---|---|---|
|<center>코드</center>|<center>-></center>|<center>메서드()<br>객체</center>|<center>-></center>|<center>값</center>|
|||<i>메타데이터와 같이 스택 영역에 있는 값의 메모리 주소만을 담고 있다고 생각하였음</i>|||

이전에 C를 다뤄보며 문자열이나 포인터 참조 수준에 따라서 `코드 -> 객체 -> 값`의 흐름으로 참조되었을 것으로 보았고 흐름의 전개에는 문제가 없었던 것으로 보이나 구조의 이해가 부족하여 잘 못된 결론에 도달했던 것으로 추정된다.

실제로 C의 구조체와 java의 객체를 비교해가며 이해를 했으나 객체의 상속 관계와 C의 구조체에서 상속과 유사하게 다른 구조체의 포인터 구조체를 이용하는 경우에서 발생하는 메모리의 저장 방식이 다름을 깨달아 묘한 괴리감이 확실해졌던 것 같다.

아래는 좀 더 명확하게 다시 정리해본 java의 메모리 구조이다.

|<center>메서드 영역</center>|<center>참조 관계</center>|<center>힙 영역</center>|<center>참조 관계</center>|<center>스택 영역</center>|
|---|---|---|---|---|
|<center>코드</center>|<center>-></center>||<center>-></center>|<center>메서드()</center>|
|||||<i>메서드 호출 시 스택 프레임 생성</i>|
||<center>-></center>||<center>-></center>|<center>메서드 지역변수</center>|
|||||<center><i>스택 프레임 내부에 위치</i></center>|
||<center>-></center>|<center>객체</center>|<center>-></center>|<center>객체 변수</center>|
||<center>-></center>|<center>객체의 필드</center>|

이처럼 힙 영역에는 단순하게 객체가 포함하고 있는 필드만 저장되며 모든 메서드는 메서드 영역에 있고 호출 되었을 때는 스택 프레임을 생성하여 내부적으로 필요한 변수와 파라미터 들에 대한 정보를 저장한다. 이어서 객체 내부에 접근이 필요할 경우, 스택에 저장된 `this` 등의 참조를 통해 접근을 한다.

### Class의 상속

이 문제를 깨닫게 한 근본적인 문제는 상속에서 발생했다. 얕은 지식으로만 알고있는 C에서는 변수와 관련된 모든 메모리는 순차적으로 할당되며, 이러한 방식으로 인해 자료형의 선언 순서와 메모리 패딩 등이 발생한다고 알고 있었다.

그렇기에 java에서도 자식 클래스에서도 동일한 방식으로 구현되어있을 것이라 생각했지만 **java와 C는 다른 언어**임을 다시한번 깨닫게 된 계기가 되었다.

결론만 말하자면 JVM에서 객체의 필드는 메모리에 순차적으로 올라가지 않으며 스스로 판단하에 불특정한 영역에 올라가는 것 같다. 따라서 변수의 선언 순서나 메모리 패딩과 같은 절차는 없으며 더 이상 해당 객체를 참조하는 변수가 없으면 GC를 통해 메모리를 정리하게 된다.

객체의 상속에서도 자식이 부모의 필드를 포함하고 있을 필요가 없으며 상속 받은 필드는 부모 클래스의 메모리에서 관리되며 자식은 부모 필드를 참조하여 값을 가져오게 된다.

<i>사실 C의 구조체에서도 동일하게 B 구조체에서 A 구조체의 포인터를 참조하면 동일하게 포인터의 크기 만큼 메모리 할당이 되고 참조된 A 구조체는 별도의 메모리 공간을 가졌을텐데 생각이 짧았던 것 같다..</i> 😅

### 결론

결국엔 java라는 언어는 사용자가 굳이 메모리 영역까지 접근하거나 조작하는 행위를 하지 않도록 설계된 언어라는 점이다. 물론 JNI를 사용할 경우 가능은 하겠으나 일반적으로 크게 쓸 일은 없을 것으로 보인다.

