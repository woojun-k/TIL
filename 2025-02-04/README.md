## 목차

### [예외 처리](#예외-처리)
- [Error](#error)
- [Exception](#exception)

### 예외 처리

- 예외 발생 시 프로그램의 비 정상 종료를 막고 정상적인 실행 상태를 유지하는 것
- 예외의 감지 및 예외 발생 시 동작할 코드 작성하고, 사용자에게 적절한 메시지 제공

#### Error

|에러|내용|
|---|---|
|컴파일 에러|컴파일 도중 컴파일러가 발견하는 오류|
|런타임 에러|컴파일은 성공적으로 진행되었으나, 프로그램 실행 중에 발생하는 오류|
|논리적 에러|컴파일도 되고 프로그램도 실행되었으나, 프로그램이 의도대로 동작하지 않는 오류<br>프로그램이 정상적으로 실행되고 종료되었지만 결과가 예상과 다른 경우|

#### Exception

- RuntimeException 클래스
    - 프로그래머의 실수로 발생
    - unchecked exception
    - 대처 코드가 없어도 컴파일 문제 없음
- Exception 클래스
    - 사용자의 실수 등 외적인 요인에 의해 발생
    - checked exception
    - 대처 코드가 없으면 컴파일 진행 할 수 없음

#### 예외 처리 키워드
- 직접 처리
    - `try {}` : 예외가 발생할 가능성이 있는 코드를 포함하는 블록
    - `catch (예외 매개 변수) {}` : 예외가 발생했을 때 실행할 코드 블록
    - `finally {}` : 예외 발생 여부와 상관없이 항상 실행되는 코드 블록
- 간접 처리(처리 위임)
    - `throws` : 메서드 선언부에 사용되며, 메서드에서 발생 가능한 예외를 호출자에게 전달
- 예외를 직접 발생시킬 때
    - `throw` : 예외를 명시적으로 발생시키는 키워드

#### 다중 예외 처리 유의 사항
- 예외 객체에 해당하는 `catch`문장을 찾을 때는 **다형성**이 적용됨
- 상위 타입의 예외가 먼저 선언되는 경우 뒤의 `catch`블록은 동작하지 않음
- 상속 관계가 없는 경우는 무관
- 상속 관계에서는 작은 범위에서 큰 범위 순으로 정의

#### Exception 인스턴스의 주요 메서드
- `getMessage()`:
- `printStackTrace()`:

#### 메서드에서 예외 던지기
 - 메서드 선언부에 `throws`키워드를 사용하여 예외 작성
 - 예외가 여러 개일 경우 `,`를 이용하여 나열
 - 메서드가 예외를 처리하는 것이 아닌 전달

##### 메서드 재정의와 throws
- 메서드 재정의 시 조상클래스 메서드가 던지는 예외보다 큰 예외를 던질 수 없음

#### finally 구문

- 예외 발생 여부와 상관 없이 언제나 실행

#### 자동 자원 반납 구문 (try with resources)

- 자원 등을 반납할 때 finally에서 close()를 통해 반납을 주로 함
- 코드가 지저분해지고 다른 예외상황을 발생시킬 수 있음

```java
try (FileInputStream fis = new FileInputStream("test")) {
    // code
} catch (IOException e) {
    e.printStackTrace();
}
```

- `try ()`: 괄호 안에 객체를 생성하는 코드를 작성하면, 해당 객체는 `close()`를 호출하지 않아도 블록을 벗어 나는 순간 `close()`가 호출 됨
- 해당 객체의 클래스가 `AutoCloseable` 이라는 인터페이스를 구현해야 함

#### 사용자 정의 예외

- 기존에 정의된 예외 이외에 사용자가 직접 정의 예외를 작성할 수 있음
- 대부분 Exception 또는 RuntimeException 클래스를 상속받아 작성
    - checked exception 활용 : 명시적 예외 처리 또는 throws 필요
    - runtime exception 활용 : 묵시적 예외 처리 가능