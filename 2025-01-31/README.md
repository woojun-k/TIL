## 목차

### [자바](#자바)
- [다형성](#다형성)
- [장점](#장점)
- [특징](#특징)
- [instanceof 연산자](#instanceof-연산자)

### [추상클래스](#추상클래스)
- [정의](#정의)
- [특징](#특징-1)
- [사용 목적](#사용-목적)

### [인터페이스](#인터페이스)

- [JDK 8, default 메서드](#jdk-8-default-메서드)
- [JDK9, private 메서드](#jdk9-private-메서드)
- [인터페이스와 다형성](#인터페이스와-다형성)
- [특징](#특징-2)

### [제네릭](#제네릭)

- [타입 파라미터](#타입-파라미터)
- [객체 생성](#객체-생성)
- [제네릭 메서드](#제네릭-메서드)
- [한정된 타입 매개변수](#한정된-타입-매개변수)
- [와일드 카드](#와일드-카드)

## 자바

### 다형성

- 하나의 객체를 다양한 타입의 참조로 사용할 수 있음
- 다양한 유형의 여러 객체를 하나의 공통도딘 타입으로 참조할 수 있음
- 상속 관계에 있을 때 조상클래스 타입으로 자손 클래스의 객체를 참조할 수 있음
- 다양한 타입으로 참조하더라도 참조만 바뀔 뿐 **실제 객체** 자체는 변함이 없음

#### 장점

- 코드의 유연성
- 코드 재사용성
- 확장성
- 유지보수성

#### 특징

- 상속 관계에서 조상 클래스 타입으로 자손 클래스 객체 잠조 가능

#### instanceof 연산자

- 

### 추상클래스

#### 정의

- 구현부가 없으므로 abstract 키워드를 메서드 선언부에 추가
- 객체를 생성할 수 없는 클래스라는 의미로 클래스 선언부에 abstract를 추가
```java
class abstract Class{
    public abstract method(){
        ...
    }
}
```

#### 특징

- abstract 클래스는 상속 전용의 클래스
- 클래스에 구현부가 없는 메서드가 있으므로 **객체를 생성할 수 없음**
- 상위 클래스 타입으로 자식을 참조할 수는 있음
```java
// 불가능
Class cls1 = new Class();
// 참조는 가능
Class cls2 = new ChildClass();
```
- 조상 클래스에서 상속 받은 abstract 메서드를 재정의 하지 않은 경우 클래스 내부에 abtract 메서드가 있으므로 자식 클래스는 abstract 클래스가 되어야 함
- 다중 상속 불가

#### 사용 목적

- 공통적인 설계 강제
- 코드 재사용성 향상
- 일관성 유지
- 다형성 지원

### 인터페이스

- 두 개체가 서로 이해할 수 있는 언어와 규칙을 정의
- 복잡한 내부 동작을 숨기고, 사용자가 단순한 방식으로 접근하도록 도움
- 표준을 정하여 다른 구성 요소들이 같은 규칙을 따르도록 함
- 완벽하게 추상화된 설계도
- JDK8 부터 `default`,`static`이 포함될 수 있음
- `interface`내에 선언된 메서드는 `public abstract`생략 가능
- `interface`내에 정의된 변수는 `public static final`로 간주되며 생략 가능

#### > JDK 8, default 메서드

- 인터페이스에 구현부가 있는 메서드를 작서할 수 있음
- `default` 명시

#### > JDK9, private 메서드

- 인터페이스 내부에서만 사용되는 헬퍼 메서드
- 디폴트 메서드, 정적 메서드에서 반복되는 로직 분리 후 작성
- 외부에서 접근하지 못하도록 숨김
- 재사용정 증가
- `static` 사용 가능

#### 인터페이스와 다형성

- 인터페이스를 구현한 클래스로 만든 객체는 해당 인터페이스 타입으로 참조할 수 있음

#### 특징

- 표준화 처리 가능
- 개발 기간 단축 가능
- 클래스들 간의 관계 형성
- 모듈 교체 용이
- 독립적 프로그래밍 가능
- 다형성 지원
- 설계의 유연성 제공

### 제네릭

- 다양한 데이터 타입을 처리할 수 있는 클래스, 인터페이스, 메서드를 작성하는 기법
- 컴파일 시점에서 데이터 타입을 지정할 수 있음
- 하나의 코드로 여러 타입에 대해 동작하게 설계 가능
- 데이터 타입을 지저하여 불필요한 타입 캐스팅 제거 가능

#### 타입 파라미터

- T: reference Type
- E: Element
- K: Key

#### 객체 생성

- 변수와 생성 타입은 반드시 일치해야 함
    ```java
    Box<Student> box = new Box<Student>(); // O
    Box<Person> box = new Box<Student>(); // x
    ```
- 추정이 가능한 경우 타입 생략 가능 > JDK1.7
- 제네릭 타입을 지정하지 않고 생성이 가능하지만 권장하지 않음 -> 기본값 \<T\>

#### 제네릭 메서드

- 타입 파라미터를 사용하는 메서드
- 클래스의 타입 파라미터와는 별개로, 메서드 레벨에서 제네릭 타입을 정의하고 사용할 수 있음
- 제네릭 메서드는 메서드의 매개변수나 반환 타입을 타입 파라미터로 지정하여 다양한 타입을 처리
- 제네릭 메서드를 정의하려면 메서드의 반환 타입 앞에 타입 파라미터를 선언

#### 한정된 타입 매개변수

- 제네릭 클래스를 정의할 때
- 구체적인 타입 제한이 필요할 경우 `extends` 사용

#### 와일드 카드

- 제네릭 클래스 인스턴스 변수의 참조 타입을 작성할 때
- 문자 `?` 사용
- 불특정 타입을 나타내기 위해 사용하는 특수한 타입 매개변수
- 제네릭 클래스에 다형성 적용 가능
    |종류|표현|설명|
    |---|---|---|
    |제한없는 와일드 카드|GenericType<?>|타입에 제한이없음|
    |상한 경계 와일드 카드|GenericType<? extends T>||
    |하한 경계 와일드 카드|GenericType<? super T>||


